#include "public.h"

//1124ms, 5.55%
//注意这种写法c++有概率TLE, 需要改进
//并查集
//挨个删, 暴力检测

class Solution {
private:
	unordered_map<int, int> um;

	void init(vector<int>& vals)
	{
		for (auto& s : vals)
		{
			um[s] = s;
		}
	}

	int GetFather(int x) {
		return (um[x] == x ? x : um[x] = GetFather(um[x]));
	}

	void Merge(int x, int y) {
		int a = GetFather(x);
		int b = GetFather(y);
		if (a != b)
		{
			um[b] = a;
		}
	}

	int removeone(const vector<vector<int>>& graph, vector<int>& initial)
	{
		//vector<vector<int>> v(graph.size(), vector<int>{});


		vector<int> vinit(graph.size(), 0);
		for (int i = 0; i < vinit.size(); ++i)
			vinit[i] = i;
		init(vinit);

		for (int i = 0; i < graph.size(); ++i)
		{
			for (int j = 0; j < graph[0].size(); ++j)
			{
				if (i == j) continue;
				else
				{
					if (graph[i][j] == 1)
					{
						//v[i].push_back(j);
						//v[j].push_back(i);
						Merge(i, j);
					}
				}
			}
		}
		//统计
		unordered_map<int, set<int>> um_father_vals;
		for (int i = 0; i < graph.size(); ++i)
		{
			um_father_vals[GetFather(i)].insert(i);
		}
		unordered_set<int> fathers;
		int res = 0;
		for (int i = 0; i < initial.size(); ++i)
		{
			int f = GetFather(initial[i]);
			if (fathers.find(f) == fathers.end())
			{
				fathers.insert(f);
				res += um_father_vals[f].size();
			}
		}
		return res;
	}

public:
	int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
		//暴力删
		sort(initial.begin(), initial.end());
		int len = INT_MAX;
		int res = -1;
		for (auto& i : initial)
		{
			vector<int> cpinitial = initial;
			cpinitial.erase(find(cpinitial.begin(), cpinitial.end(), i));

			int templen = removeone(graph, cpinitial);

			if (templen < len)
			{
				len = templen;
				res = i;
			}
		}
		return res;
	}
};

